<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Future Levee Predictor</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://unpkg.com/chartjs-plugin-annotation@1.1.0"></script>
<style>
  body { font-family: 'Helvetica Neue', sans-serif; margin: 0; padding: 0; }
  .container { display: flex; flex-direction: row; height: 100vh; }
  .sidebar { width: 30%; background: #f9f9f9; padding: 20px; overflow-y: auto; border-right: 1px solid #e0e0e0; }
  .map-container { flex: 1.4; position: relative; }
  #map { width: 100%; height: 100%; position: absolute; }
  select, table, button { width: 100%; margin-top: 10px; padding: 8px; border-radius: 8px; }
  .predict-btn, .download-btn { background-color: #6995c2; color: white; border: none; font-weight: bold; cursor: pointer; }
  .predict-result { margin-top: 20px; background: white; padding: 16px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); display: none; }
  table { border-collapse: collapse; }
  td, th { border: 1px solid #ccc; padding: 6px; text-align: center; }

.levee-select {
  width: 100%; /* æ‹‰åˆ°æ»¿ç‰ˆ */
  padding: 8px;
  font-size: 16px;
  color: #6c7a89; /* ç°è—è‰²æ–‡å­— */
  border: 2px solid #6c7a89; /* ç°è—è‰²é‚Šæ¡† */
  border-radius: 8px; /* é‚Šè§’åœ“åœ“ */
  background-color: white; /* èƒŒæ™¯ç™½è‰² */
  appearance: none; /* ç§»é™¤é è¨­ç³»çµ±æ¨£å¼ï¼ˆæ›´ä¸€è‡´ï¼‰ */
  -webkit-appearance: none; /* Safariç”¨ */
  -moz-appearance: none; /* Firefoxç”¨ */
}

.levee-select:focus {
  border-color: #5f9ea0; /* é»é¸æ™‚ï¼Œé‚Šæ¡†è®Šäº®ä¸€é»çš„è—è‰² */
  outline: none;
}



  .levee-title {
  color: #6995c2; /* ç°è—è‰²å­—é«” */
  font-size: 28px; /* å­—é«”å¤§å° */
  font-weight: bold; /* å­—é«”åŠ ç²— */
  text-align: center; /* ç½®ä¸­å°é½Š */
  margin-top: 20px; /* ä¸Šæ–¹ç•™ç©º */
  margin-bottom: 10px; /* ä¸‹æ–¹ç•™ç©º */
  font-family: 'Helvetica Neue', sans-serif; /* å­—é«”æ— */
}


  .water-table-wrapper {
  max-height: 300px; /* çœ‹ä½ æƒ³å¤šé«˜ï¼Œå¯ä»¥è‡ªå·±èª¿ï¼Œåƒ250pxæˆ–200pxä¹Ÿè¡Œ */
  overflow-y: auto; /* åªå‡ºç¾å‚ç›´çš„æ²è»¸ */
  border: 1px solid #ccc;
  border-radius: 8px;
  margin-top: 10px;
}
#water-table {
  width: 100%;
  border-collapse: collapse;
  color: #6388ad;
}
#water-table td, #water-table th {
  border: 1px solid #ccc;
  padding: 6px;
  text-align: center;
}
</style>
</head>
<body>
<div class="container">
  <div class="sidebar">
    <h2 class="levee-title">Levee Predictor</h2>

      <select class="levee-select" onchange="selectLevee(this.value)">
        <option value="">Select site</option>
        <option value="Site 2">Site 2</option>
        <option value="Site 3">Site 3</option>
        <option value="Site 4">Site 4</option>
      </select>

    <div class="water-table-wrapper">
  <table id="water-table"></table>
</div>
    <button class="predict-btn" onclick="predict()">Predict</button>
    <div id="loading-message" style="display:none; margin-top:10px; text-align:center; color:gray;">
  ğŸ”„ Predicting... Please wait...
</div>
    <div id="predict-result" class="predict-result">
      <canvas id="chartCanvas" width="300" height="150"></canvas>
      <button class="download-btn" onclick="downloadChart()">Download Chart</button>
      <div id="summary" style="margin-top:10px; font-size:14px;"></div>
    </div>
  </div>
  <div class="map-container">
    <div id="map"></div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
<script>
const map = L.map('map').setView([41.2877, -75.8678], 15);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

const leveeSites = [
  {lat:41.2877, lng:-75.8678, name:"Site 2", image:"/static/images/site2.png"},
  {lat:41.2608, lng:-75.8767, name:"Site 3", image:"/static/images/site3.png"},
  {lat:41.2518, lng:-75.8872, name:"Site 4", image:"/static/images/site4.png"}
];

let markers = leveeSites.map(site =>
  L.marker([site.lat, site.lng]).addTo(map).bindPopup(`
    <div style="text-align:center;">
      <b>${site.name}</b><br>
      Coordinates: ${site.lat.toFixed(4)}, ${site.lng.toFixed(4)}<br>
      <img src="${site.image}" alt="Site Image" style="width:150px; margin-top:5px; border-radius:8px;">
    </div>
  `)
);

function selectLevee(name) {
  const marker = markers.find(m => m.getPopup().getContent().includes(name));
  if (marker) {
    map.setView(marker.getLatLng(), 17);
    marker.openPopup();
  }
}

function initializeTable() {
  const table = document.getElementById('water-table');
  table.innerHTML = '<tr><th>Day</th><th>Level (ft)</th></tr>' +
    Array.from({length: 20}, (_,i)=>`
      <tr>
        <td>${i+1}</td>
        <td><input type="text" value="30" data-row="${i}" data-col="0" style="width:80px; text-align:center;"></td>
      </tr>`).join('');
}
document.addEventListener('paste', function(e) {
  const active = document.activeElement;
  if (active && active.tagName === 'INPUT' && active.closest('#water-table')) {
    e.preventDefault();
    const clipboardData = e.clipboardData || window.clipboardData;
    const pastedData = clipboardData.getData('text');

    // ä»¥æ›è¡Œåˆ†é–‹è²¼ä¸Šçš„è³‡æ–™
    const values = pastedData.split(/\r?\n/).map(v => v.trim()).filter(v => v !== '');

    let row = parseInt(active.dataset.row);

    values.forEach((val, idx) => {
      const targetInput = document.querySelector(`input[data-row="${row + idx}"][data-col="0"]`);
      if (targetInput) {
        targetInput.value = val;
      }
    });
  }
});


function getTableData() {
  const table = document.getElementById('water-table');
  const inputs = table.querySelectorAll('input');
  const levels = [];
  inputs.forEach(input => {
    const value = parseFloat(input.value.trim());
    levels.push(isNaN(value) ? 0 : value);
  });
  return levels;
}


function interpolateWaterLevels(data) {
  const result = [];
  for (let i = 0; i < data.length - 1; i++) {
    const start = data[i];
    const end = data[i+1];
    result.push(start);
    result.push((start + end) / 2);
  }
  result.push(data[data.length-1]);
  return result;
}
let isPredicting = false;
function predict() {
  const waterDataOriginal = getTableData();
  if (waterDataOriginal.length !== 20) {
    alert('Please enter exactly 20 water level values.');
    return;
  }
  const waterData = interpolateWaterLevels(waterDataOriginal);

console.log("ğŸ“¤ Sending fetch to /predict", waterDataOriginal);

fetch('https://leveepredictor-production.up.railway.app/', {

  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ water_levels: waterDataOriginal })
})

  .then(response => response.json())
  .then(data => {
    if (data.error) {
      alert("âš ï¸ Error: " + data.error);
      return;
    }

    document.getElementById('predict-result').style.display = 'block';
    document.getElementById('predict-result').scrollIntoView({behavior: 'smooth'});

    const ctx = document.getElementById('chartCanvas').getContext('2d');
    if (window.chart) window.chart.destroy();

    const labels = Array.from({length: 40}, (_, i) => (i + 1) / 2);
    const fs1Data = data.fs1.map((v, i) => ({ x: labels[i], y: v }));
    const fs2Data = data.fs2.map((v, i) => ({ x: labels[i], y: v }));
    const waterLevelData = waterData.map((v, i) => ({ x: labels[i], y: v }));

    window.chart = new Chart(ctx, {
      type: 'line',
      data: {
        datasets: [
          {
            label: 'Toe of Levee',
            data: fs1Data,
            parsing: true,
            backgroundColor: data.fs1.map(v => v < 1 ? '#cc0000' : '#cccccc'),
            borderColor: data.fs1.map(v => v < 1 ? '#cc0000' : '#cccccc'),
            borderWidth: 1.5,
            pointRadius: 2,
            tension: 0.4
          },
          {
            label: 'Toe of Berm',
            data: fs2Data,
            parsing: true,
            backgroundColor: data.fs2.map(v => v < 1 ? '#cc0000' : '#666666'),
            borderColor: data.fs2.map(v => v < 1 ? '#cc0000' : '#666666'),
            borderWidth: 1.5,
            pointRadius: 2,
            tension: 0.4
          },
          {
            label: 'Water Level (ft)',
            data: waterLevelData,
            parsing: true,
            borderColor: 'lightblue',
            backgroundColor: 'lightblue',
            borderWidth: 1.5,
            pointRadius: 0,
            tension: 0.4,
            yAxisID: 'y1'
          }
        ]
      },
      options: {
        scales: {
          x: {
            type: 'linear',
            title: { display: true, text: 'Day' },
            ticks: { stepSize: 1, callback: val => Number.isInteger(val) ? val : '' },
            min: 1,
            max: 20
          },
          y: {
            min: 0,
            max: 6,
            title: { display: true, text: 'FS' },
            position: 'left'
          },
          y1: {
            type: 'linear',
            position: 'right',
            title: { display: true, text: 'Water Level (ft)' },
            grid: { drawOnChartArea: false }
          }
        },
        plugins: {
          tooltip: {
            callbacks: {
              label: function(context) {
                return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}`;
              }
            }
          },
          annotation: {
            annotations: {
              line1: {
                type: 'line',
                yMin: 1,
                yMax: 1,
                borderColor: 'red',
                borderWidth: 1,
                borderDash: [6,6]
              }
            }
          }
        }
      }
    });

    const dangerIndices = [];
    data.fs1.forEach((v, i) => { if (v < 1) dangerIndices.push((i + 1) / 2); });
    data.fs2.forEach((v, i) => { if (v < 1) dangerIndices.push((i + 1) / 2); });

    const summary = document.getElementById('summary');
    if (dangerIndices.length > 0) {
      const firstDangerDay = Math.min(...dangerIndices);
      summary.innerHTML = `<span style='color:red;font-weight:bold;'>âš ï¸ Warning!</span><span style='color:gray;'> Potential seepage failure first detected at Day ${firstDangerDay}. Consequences may include piping, heaving, sand boils, and local collapse of levee structures. Immediate engineering assessment and mitigation actions are highly recommended.</span>`;
    } else {
      summary.innerHTML = `<span style='color:green;font-weight:bold;'>âœ… Safe</span>`;
    }
  })
  .catch(err => {
    alert("âŒ Network error: " + err.message);
  });
}

function downloadChart() {
  const link = document.createElement('a');
  link.download = 'levee_prediction_chart.png';
  link.href = chart.toBase64Image();
  link.click();
}

// === Initialize water table ===
initializeTable();

// === Add keyboard navigation for water table ===
document.addEventListener('keydown', function(e) {
  const active = document.activeElement;
  if (active && active.tagName === 'TD' && active.isContentEditable) {
    const currentCell = active;
    const currentRow = currentCell.parentElement;
    const table = document.getElementById('water-table');
    const rows = Array.from(table.querySelectorAll('tr')).slice(1); // skip header
    const rowIndex = rows.indexOf(currentRow);
    const cellIndex = Array.from(currentRow.children).indexOf(currentCell);

    let nextCell = null;

    if (e.key === 'Enter' || e.key === 'ArrowDown') {
      e.preventDefault();
      if (rowIndex + 1 < rows.length) {
        nextCell = rows[rowIndex + 1].children[cellIndex];
      }
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (rowIndex - 1 >= 0) {
        nextCell = rows[rowIndex - 1].children[cellIndex];
      }
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      if (cellIndex + 1 < currentRow.children.length) {
        nextCell = currentRow.children[cellIndex + 1];
      }
    } else if (e.key === 'ArrowLeft') {
      e.preventDefault();
      if (cellIndex - 1 >= 0) {
        nextCell = currentRow.children[cellIndex - 1];
      }
    }

    if (nextCell && nextCell.isContentEditable) {
      nextCell.focus();
    }
  }
});
</script>
</body>
</html>
